\documentclass[11pt,a4paper]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{graphicx}
\lstset{
    basicstyle=\ttfamily\small,
    columns=fullflexible,
    keepspaces=true,
    frame=single,
    breaklines=true,
    showstringspaces=false,
    tabsize=4,
    language={[x86masm]Assembler},
    captionpos=b
}

% Tell listings what NASM looks like
\lstdefinelanguage{nasm}{
  keywords      = {section,global,call,ret,loop,align},
  morekeywords  = {mov,lea,push,shl,int3},   % =\lstkeywordstyle
  ndkeywords    = {rax,rcx,rdi,rip,al},      % registers, =\lstndkeywordstyle
  comment       = [l]{;},                    % ; starts a comment
  sensitive     = true
}

% Define a style for bash listings
\lstdefinestyle{bash-nonitalic}{
  language=bash,
  basicstyle=\ttfamily\small,
  commentstyle=\ttfamily\color{gray},  % <- not italic
  keywordstyle=\color{blue},
  showstringspaces=false,
  breaklines=true
}

% Global style: tweak as you wish
\lstset{
  language         = nasm,
  basicstyle       = \ttfamily\footnotesize,
  keywordstyle     = \color{blue!70!black}\bfseries,
  ndkeywordstyle   = \color{teal!70!black},
  commentstyle     = \color{gray}\itshape,
  stringstyle      = \color{orange!80!black},
  numbers          = left,
  numberstyle      = \tiny\color{gray},
  frame            = tb,          % top+bottom rule
  backgroundcolor  = \color{black!2},
  columns          = fullflexible,
  tabsize          = 4,
}

\title{A practical PB Inception Attack and Implications for Confidential Computing}
\author{Kaya Ercihan, Jonathan MÃ¼ller}
\date{23.12.2025}

\begin{document}
\bibliographystyle{IEEEtranS}  % IEEE, sorted
\maketitle

% ##############################################################################################
% 
%   Structure of documentation
% 
% ##############################################################################################
%\section{Intoduction}
%\section{Related Work}
%\subsection{Contribution} %
%\section{Methodology}
%\section{Experiments}
%\section{Results and Discussion}
%\section{Future Work}
%\section{Conclusion}
%\section{Appendix}

\section*{Abstract}
ToDo

\section{Intoduction}
ToDo
\subsection{Use Case: Confidential Computing}
Confidential computing encrypts memory (including instructions and data) using keys managed by the AMD Secure Processor (ASP). Secure Encrypted Virtualization (SEV) encrypts the entire VM memory, so instructions and data remain encrypted while stored in RAM. Only the CPU decrypts them on-the-fly during execution.

SEV-SNP adds integrity protection, ensuring that the hypervisor cannot tamper with or remap the VM's memory. This prevents attacks like memory snooping or VM breakout, even from a compromised hypervisor.

The ASP manages the encryption keys and secure context but does not perform decryption itself. Instead, decryption happens within the CPU, tightly integrated into the memory controller and instruction pipeline. Therefore, memory remains encrypted at rest and in transit, and is only decrypted in the CPU, for the correct VM.
\clearpage

\section{Related Work}
\label{sec:related}

\paragraph{Speculative execution and Spectre lineage.} Modern out-of-order processors predict control flow to keep pipelines full, enabling transient execution along mispredicted paths. The Spectre family formalized practical exploitation of such mispredictions and showed cross-domain leaks via microarchitectural side channels \cite{kocher2018spectre}. Since then, a broad line of work has mapped and exploited branch-prediction structures (PHT/BTB/RSB) across privilege and context boundaries.

\paragraph{RSB- and return-centric attacks.}
Early RSB-focused works (SpectreRSB and ret2spec) showed how return-target prediction can be subverted even without direct control over indirect branches \cite{koruyeh2018spectrersb,maisuradze2018ret2spec}. RETbleed systematized cross-privilege return hijacking and demonstrated end-to-end leaks on AMD and Intel by steering returns via BTB collisions; it also evaluated practical kernel mitigations (e.g. \texttt{jmp2ret}, RSB clearing/stuffing, and retpoline interactions) \cite{wikner2022retbleed}.

\paragraph{AMD Zen microarchitectures, BTC, and early speculation.}
On AMD Zen, Branch Type Confusion (BTC) and PHANTOM speculation reveal that prediction can occur very early in the frontend, including on non-branch instructions, increasing attack surface and interacting with return prediction \cite{amd2022btc,wikner2023phantom}. AMD introduced controls like \texttt{SuppressBPOnNonBr} and guidance for managing speculation across Zen generations \cite{amd2022btc,amd_software_spec}.

\paragraph{INCEPTION / SRSO.}
\emph{INCEPTION} (a.k.a.\ Speculative Return Stack Overflow, SRSO, CVE-2023-20569) shows that attackers can inject return predictions, creating long transient windows to disclose kernel data on all AMD Zen generations, despite deployed defenses \cite{trujillo2023inception,nvd_cve_2023_20569,amd_sb7005,linux_srso_doc}. Vendor whitepapers and kernel documentation discuss mitigations (IBPB-on-entry, RSB stuffing, untrained returns), trade-offs, and microcode dependencies on different Zen generations \cite{amd_srso_whitepaper,linux_srso_doc}.

\paragraph{IBPB, post-barrier speculation, and PB-Inception.}
A central defense for cross-context Spectre-BTI is the Indirect Branch Predictor Barrier (IBPB). However, the correctness of IBPB relies on microcode semantics and how software applies it. Recent analysis shows that IBPB does not fully flush all alternate return predictors. For Intel Golden/Raptor Cove, PB-RRSBA enables stale IP-based return predictions post-IBPB; for AMD Zen1(+)/Zen2, IBPB-on-entry still leaves the return predictor retaining poisoned entries learned just before the barrier, enabling PB-Inception to leak arbitrary kernel memory \cite{wikner2025breaking}. The work proposes disabling exploitable RRSBA predictions via a chicken bit on affected Intel CPUs, and hardening Linux on AMD by stuffing the RSB when using IBPB-on-entry to prevent post-barrier return hijacks \cite{wikner2025breaking}. These findings connect to earlier vendor advisories on post-barrier return prediction (PBRSB) and RRSBA enumeration/mitigation \cite{intel_pbrsb,intel_rrsba}.

\paragraph{System response and current practice.}
Linux now documents SRSO/RSB mitigations (IBPB strategies, untrained returns, RSB stuffing and conditions for applying them) and their performance-security tradeoffs. The effectiveness varies by microarchitecture and available microcode \cite{linux_srso_doc,linux_rsb_doc}. On AMD Zen3/4, IBPB may flush IP-based predictors to mitigate INCEPTION-like behaviors, while Zen1/2 require software RSB stuffing on entry when IBPB is used \cite{wikner2025breaking,amd_srso_whitepaper}.

\paragraph{Takeaway.}
For AMD Zen, the return predictor remains a privileged choke point: pre-barrier mistraining plus post-barrier retention under specific IBPB configurations yields PB-Inception-style cross-privilege leaks. Comprehensive defenses require both correct barrier semantics in microcode \emph{and} software-side RSB sanitization at the right points in the control-flow transitions \cite{wikner2025breaking,trujillo2023inception,linux_srso_doc}.

\section{Contribution}
ToDo

\section{Methodology}

\paragraph{Goal.}
Demonstrate a post-IBPB Spectre primitive on AMD Family Zen~1(+)/2 whereby return-target predictions, mistrained before an IBPB, survive the barrier and steer the first ret in the kernel entry path to a chosen leak gadget (PB-Inception). We further instantiate the primitive in a Confidential Computing (CC) setting (AMD SEV-SNP) by exfiltrating secrets into an unencrypted shared buffer (C-bit=0) observable by the host.

\paragraph{Threat model.}
An unprivileged attacker process (inside a Linux guest) aims to infer kernel-resident data across a user$\rightarrow$kernel boundary that issues IBPB-on-entry. The attacker controls userland code and can load a benign kernel module in the guest for experimental instrumentation. The host is passive and only performs measurements on a shared buffer. No architectural faults or privilege escalations are used.

\paragraph{Preconditions.}
(i) AMD Family~17h (Zen~1/2) where return-target predictions persist across IBPB; (ii) the Linux entry path executes entry\_ibpb (wrmsr to IBPB) and then performs an early ret; (iii) a kernel leak gadget reachable under speculative control, producing a cache-disclosed signal; (iv) CC flags present (SEV/SEV-ES/SEV-SNP) and availability of a guest page with C-bit cleared to act as a host-observable probe.%

The flags can under Linux be found with the command \texttt{lscpu} by checking the advertised flags "SEV", "SEV-ES", "SEV-SNP" in the following way:
\begin{lstlisting}[language=bash]
Architecture:        x86_64
CPU op-mode(s):      32-bit, 64-bit
Byte Order:          Little Endian
Address sizes:       48 bits physical, 48 bits virtual
CPU(s):              8
On-line CPU(s) list: 0-7
Thread(s) per core:  2
Core(s) per socket:  4
Socket(s):           1
NUMA node(s):        1
Vendor ID:           AuthenticAMD
CPU family:          25
Model:               1
Model name:          AMD EPYC 7B13
Stepping:            0
CPU MHz:             3049.994
BogoMIPS:            6099.98
Virtualization:      AMD-V
L1d cache:           32K
L1i cache:           32K
L2 cache:            512K
L3 cache:            16M

Flags:
fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov 
pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt 
pdpe1gb rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid 
extd_apicid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid 
sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand 
hypervisor lahf_lm cmp_legacy cr8_legacy abm sse4a misalignsse 
3dnowprefetch osvw topoext invpcid_single ssbd ibrs ibpb stibp 
vmmcall fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid 
rdseed adx smap clflushopt clwb sha_ni xsaveopt xsaves xgetbv1 
clzero xsaveerptr arat npt nrip_save umip vaes sev sev-es sev-snp
\end{lstlisting}

\subsubsection{Overview of the exploit flow}
\label{sec:method:pb-inception:overview}
PB-Inception proceeds in three phases:

\begin{enumerate}
  \item \textbf{Pre-IBPB transient training (user mode).} We execute a transient-only call cascade to poison return predictions with addresses that alias a chosen kernel gadget. The cascade is \emph{Training-in-Transient-Execution} (TTE): a mispredicted backward \texttt{Jcc} keeps the predicate unresolved while a sequence of 64 \texttt{call}-sites (\texttt{TRAMP\_COUNT}) issues \emph{speculative} \texttt{CALL}s. None of these calls retire architecturally, they only push return addresses into the return predictor. A deliberately ``slow'' load on the branch predicate (mapped cold memory) widens the speculation window.
  \item \textbf{Crossing the IBPB boundary.} We invoke a system call (getpid) so the kernel executes \texttt{entry\_ibpb} early in the entry path (wrmsr to IBPB) and then performs the first post-IBPB \texttt{ret}. Because return-target predictions persist across IBPB on Zen1/2, that \texttt{ret} speculatively follows our poisoned predictions.
  \item \textbf{Speculative leak and recovery.} The mispredicted return lands in a kernel \emph{data-cache (DC) leak gadget} that loads one byte from a chosen kernel virtual address and encodes it as a cache footprint at offset \texttt{val\,$\ll$\,12} in a 1\,MiB probe buffer. The probe buffer is mapped in the guest but backed by guest-physical memory with C-bit=0 and \emph{also} ioremapped cached in the kernel, so the host can recover the byte via Flush+Reload.
\end{enumerate}

\subsubsection{Implementation details (as used in our harness)}
\label{sec:method:pb-inception:impl}

\paragraph{Kernel gadget LKM.}
We load a minimal LKM that exports \texttt{pbinc\_dc\_gadget()} and wires three sysfs controls under \texttt{/sys/kernel/pbinc/}: (i) \texttt{probe} (guest-physical base of the shared 1\,MiB probe, ioremapped with \texttt{ioremap\_cache()}), (ii) \texttt{leak} (kernel VA to read the secret byte), and (iii) \texttt{gaddr} (the gadget's kernel VA for alias matching). The gadget performs:
\[
\text{\texttt{val = *leak\_source\_va;\quad writeb(1, probe\_kva + (val << 12));}}
\]
which yields a strong Flush+Reload signal while keeping the architectural path benign.


\paragraph{Return-address aliasing trampolines.}
To bias the return predictor toward \texttt{pbinc\_dc\_gadget}, we JIT-build executable \emph{trampolines} whose \emph{return addresses} (the instruction immediately after a call) share the same low-bit alias class as the gadget (\texttt{ALIAS\_MASK = 0xFFFFF}). We scan an RX region to place 64 trampolines whose post-call RAs satisfy
\[
(\texttt{RA} \ \&\ \texttt{ALIAS\_MASK}) = (\texttt{gaddr} \ \&\ \texttt{ALIAS\_MASK}),
\]
and store their entry pointers in \texttt{\_\_alias\_tbl[64]}.

\paragraph{TTE call cascade.}
User-mode assembly \texttt{pbinc\_entry} executes:
\begin{enumerate}
  \item a forward jump to skip the cascade architecturally
  \item a backward jump \texttt{JE} whose condition is delayed via a load from \texttt{\_\_slow\_predicate\_ptr};
  \item in the mispredicted path, a loop of 64 call instructions, each through \texttt{\_\_alias\_tbl[i]}, pushing colliding RAs and overflowing return prediction state
  \item a \texttt{syscall} to \texttt{getpid} (triggers entry-IBPB).
\end{enumerate}
The cascade is arranged so no call retires, it only perturbs return predictions.

\paragraph{Crossing IBPB and hijacking the first return.}
Linux enters the kernel, executes \texttt{entry\_ibpb} (wrmsr to IBPB), then returns into the regular entry path. On AMD Zen1/2, IBPB does not invalidate return-target predictions; hence the first \texttt{ret} post-IBPB speculates to our gadget. We intentionally target a very early return in the entry path (before stack randomization) to maximize stability and cache-control over the speculation window.

\paragraph{Covert channel and measurement.}
The host (or a separate monitoring thread) performs Flush+Reload over the 1\,MiB probe (256 pages at 4\,KiB spacing). Each speculative byte sets exactly one page hot at offset \texttt{val\,$\ll$\,12}. For runs under SEV-SNP, we allocate the probe page(s) as shared (C-bit=0) and pass the guest-physical base to the LKM via \texttt{/sys/kernel/pbinc/probe}. This preserves the CC threat model while allowing the host to measure cache state.

\subsubsection{Confidential Computing context (SEV-SNP)}
\label{sec:method:pb-inception:cc}
We verify CC availability with \texttt{lscpu} flags \texttt{sev}, \texttt{sev-es}, and \texttt{sev-snp}. For leakage, the probe buffer must be \emph{unencrypted} (C-bit=0) so that a host Flush+Reload can observe the signal while the victim code and kernel data remain protected at rest. The core mechanism remains speculative and in-core: decrypted instructions/data are processed transiently even under SEV-SNP, and microarchitectural footprints on shared memory are observable.

\subsubsection{Controls and validation}
\label{sec:method:pb-inception:controls}
We validate causality with the following A/B toggles:
\begin{itemize}
  \item \textbf{Mitigation toggle:} disable IBPB-on-entry or add full RSB stuffing at kernel entry $\Rightarrow$ signal vanishes.
  \item \textbf{Gadget toggle:} unload the LKM or point \texttt{leak} to an unmapped address $\Rightarrow$ no hits.
  \item \textbf{Aliasing toggle:} randomize \texttt{ALIAS\_MASK} or build zero trampolines $\Rightarrow$ no hijack.
  \item \textbf{Microarchitecture toggle:} run on non-Zen1/2 AMD or Intel $\Rightarrow$ negative (as expected for PB-Inception).
  \item \textbf{Performance counters:} observe elevated branch-miss and machine-clear events during active runs.
\end{itemize}

\subsubsection{Assumptions, limitations, and ethics}
\label{sec:method:pb-inception:limits}
PB-Inception relies on (i) persistence of return-target predictions across IBPB on AMD Zen1/2, (ii) an early \texttt{ret} after \texttt{entry\_ibpb}, and (iii) availability of a kernel leak gadget. Systems that untrain/stuff the RSB on entry, remove early returns, or alter IBPB application semantics invalidate the preconditions.

\subsubsection{Reproducibility checklist}
\label{sec:method:pb-inception:repro}
\begin{enumerate}
  \item Pin attacker to a single core; record \texttt{/sys/devices/system/cpu/vulnerabilities/spectre\_v2}.
  \item Build and insert the LKM; provision \texttt{probe} (GPA of C-bit=0 buffer), \texttt{leak} (KVA), and read \texttt{gaddr}.
  \item Build user binary with trampolines (64 entries, \texttt{ALIAS\_MASK} tuned to the gadget).
  \item Run \texttt{pbinc\_poc} and start host Flush+Reload over the 1\,MiB probe.
  \item Collect latency histograms. Confirm single-page hits at offsets \texttt{val\,$\ll$\,12}; execute controls in~\S\ref{sec:method:pb-inception:controls}.
\end{enumerate}

\section{Experiments}
ToDo

\section{Results and Discussion}
ToDo

\section{Future Work}
ToDo

\section{Conclusion}
ToDo



\bibliography{refs}
\end{document}
