\documentclass[11pt,a4paper]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\lstset{
    basicstyle=\ttfamily\small,
    columns=fullflexible,
    keepspaces=true,
    frame=single,
    breaklines=true,
    showstringspaces=false,
    tabsize=4,
    language={[x86masm]Assembler},
    captionpos=b
}

% Tell listings what NASM looks like
\lstdefinelanguage{nasm}{
  keywords      = {section,global,call,ret,loop,align},
  morekeywords  = {mov,lea,push,shl,int3},   % =\lstkeywordstyle
  ndkeywords    = {rax,rcx,rdi,rip,al},      % registers, =\lstndkeywordstyle
  comment       = [l]{;},                    % ; starts a comment
  sensitive     = true
}

% Define a style for bash listings
\lstdefinestyle{bash-nonitalic}{
  language=bash,
  basicstyle=\ttfamily\small,
  commentstyle=\ttfamily\color{gray},  % <- not italic
  keywordstyle=\color{blue},
  showstringspaces=false,
  breaklines=true
}

% Global style: tweak as you wish
\lstset{
  language         = nasm,
  basicstyle       = \ttfamily\footnotesize,
  keywordstyle     = \color{blue!70!black}\bfseries,
  ndkeywordstyle   = \color{teal!70!black},
  commentstyle     = \color{gray}\itshape,
  stringstyle      = \color{orange!80!black},
  numbers          = left,
  numberstyle      = \tiny\color{gray},
  frame            = tb,          % top+bottom rule
  backgroundcolor  = \color{black!2},
  columns          = fullflexible,
  tabsize          = 4,
}

\title{Speculative-Execution Attacks and Implications for Confidential Computing}
\author{Kaya Ercihan, Jonathan Müller}
\date{28.07.2025}

\begin{document}
\bibliographystyle{IEEEtranS}  % IEEE, sorted
\maketitle

\section*{Abstract}
ToDo

\section{Term Details}
ToDo

\section{Use Case: Confidential Computing}
Confidential computing encrypts memory (including instructions and data) using keys managed by the AMD Secure Processor (ASP). Secure Encrypted Virtualization (SEV) encrypts the entire VM memory, so instructions and data remain encrypted while stored in RAM. Only the CPU decrypts them on-the-fly during execution.

SEV-SNP adds integrity protection, ensuring that the hypervisor cannot tamper with or remap the VM's memory. This prevents attacks like memory snooping or VM breakout, even from a compromised hypervisor.

The ASP manages the encryption keys and secure context but does not perform decryption itself. Instead, decryption happens within the CPU, tightly integrated into the memory controller and instruction pipeline. Therefore, memory remains encrypted at rest and in transit, and is only decrypted in the CPU, for the correct VM.
\clearpage

\subsection{Detecting CC Support}
If a CPU supports confidential computing can easily be verified with the flags in lscpu (Flags: "sev", "sev-es", "sev-snp"):

\begin{lstlisting}[language=bash]
Architecture:        x86_64
CPU op-mode(s):      32-bit, 64-bit
Byte Order:          Little Endian
Address sizes:       48 bits physical, 48 bits virtual
CPU(s):              8
On-line CPU(s) list: 0-7
Thread(s) per core:  2
Core(s) per socket:  4
Socket(s):           1
NUMA node(s):        1
Vendor ID:           AuthenticAMD
CPU family:          25
Model:               1
Model name:          AMD EPYC 7B13
Stepping:            0
CPU MHz:             3049.994
BogoMIPS:            6099.98
Virtualization:      AMD-V
L1d cache:           32K
L1i cache:           32K
L2 cache:            512K
L3 cache:            16M

Flags:
fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov 
pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt 
pdpe1gb rdtscp lm constant_tsc rep_good nopl nonstop_tsc cpuid 
extd_apicid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid 
sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand 
hypervisor lahf_lm cmp_legacy cr8_legacy abm sse4a misalignsse 
3dnowprefetch osvw topoext invpcid_single ssbd ibrs ibpb stibp 
vmmcall fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid 
rdseed adx smap clflushopt clwb sha_ni xsaveopt xsaves xgetbv1 
clzero xsaveerptr arat npt nrip_save umip vaes sev sev-es sev-snp
\end{lstlisting}

\section{How to circumvent confidential computing?}
There are multiple ways to circumvent CC with this new kind of vulnerability. One is that the attacker crafts special payloads to train the CPU in a way to return in the victim's process to a wrong memory address. This would circumvent the CC measures because the memory, which stays encrypted with the instructions within cannot be read directly but the process which executes instructions, only decrypted in the CPU, will be running in an attacker controllable space and so the information output of the data within the instructions is than in an unencrypted attacker controllable space.

\section{Proof of Concept: RRSBA Poisoning -> valid till Linux kernel < 6.9 or missing flags}
Post‑Barrier Return Stack Buffer Alternate (PB‑RRSBA) attacks abuse the fallback “alternate” return predictor that takes over when the architectural RSB under‑flows. Intel now exposes two architectural bits in \texttt{IA32\_SPEC\_CTRL} to disable that predictor bit 5 \texttt{RRSBA\_DIS\_U} (user mode) and bit 6 \texttt{RRSBA\_DIS\_S} (kernel mode). If either bit is 1 the predictor is gated off for that privilege level, closing PB‑RRSBA.

Kernel support for programming those bits first appeared in Linux 6.9 (May 2024).  The x86 tree gained \texttt{spectre\_v2=rrsba\_disable}, and the scheduler now sets the bits automatically when the CPU advertises \texttt{RRSBA\_CTRL}. Earlier kernels leave both bits at their reset value 0, so the predictor stays enabled even after an IBPB.\\

\vspace{-0.5em}
\begin{lstlisting}[style=bash-nonitalic, caption={\texttt{attacker\_rrsba\_injection\_test.sh}}]
neo@morpheus:~$ sudo rdmsr -0 0x48 | awk '{printf "IA32_SPEC_CTRL = 0x%x\n",$1}'
IA32_SPEC_CTRL = 0x191
neo@morpheus:~$
neo@morpheus:~$ grep -o "RRSBA_CTRL" /proc/cpuinfo || cpuid -r | grep RRSBA_CTR
neo@morpheus:~$
neo@morpheus:~$ cat /sys/devices/system/cpu/vulnerabilities/itlb_multihit /sys/devices/system/cpu/vulnerabilities/spectre_v2
Not affected
Mitigation: Enhanced / Automatic IBRS; IBPB: conditional; PBRSB-eIBRS: SW sequence; BHI: BHI_DIS_S
neo@morpheus:~$

# Short explaination:
# rdmsr decoding
# IA32_SPEC_CTRL = 0x191
# => 0b0001 1001 0001
#         ^ ^||^    ^ bits 8,7,4,0 = 1 (PSFD, DDPD_U, IPRED_DIS_S, IBRS)
#            ^|       bits 6 (RRSBA_DIS_S)=0 <- kernel predictor still active
#             ^       bit 5 (RRSBA_DIS_U)=0  <- user space predictor still active
# Bit 0 (IBRS) -> enhanced / automatic Indirect Branch Restricted Speculation
# is enabled.
# Bit 4 (IPRED_DIS_S) -> the kernel has disabled the legacy IP based indirect
# predictor.
# Bit 7 (PSFD) -> Fast Store Forwarding predictor is disabled.
# Bit 8 (DDPD_U) -> the usermode Data Dependent Prefetcher is disabled.

# cpuid / RRSBA feature
#(no output) <- CPU/firmware do not advertise RRSBA_CTRL; bits cannot be set

# sysfs
# RRSBA not mentioned -> kernel < 6.9 (or old microcode) so RRSBA remains enabled
\end{lstlisting}


\section{Conclusion}
ToDo

\bibliography{refs}
\end{document}
